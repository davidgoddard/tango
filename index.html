<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Author: David Goddard
  A tanda based music player for Tango DJs">
  <title>Tanda Player Lite</title>

  <meta http-equiv="Cross-Origin-Opener-Policy" content="same-origin">
  <meta http-equiv="Cross-Origin-Embedder-Policy" content="require-corp">


  <link rel="manifest" href="./manifest.json">
  <link rel="stylesheet" href="./css/styles.css">
  <script type="module" src="./components/file.element.js"></script>
  <script type="module" src="./components/track.element.js"></script>
  <script type="module" src="./components/tanda.element.js"></script>
  <script type="module" src="./components/playlist.element.js"></script>
  <script type="module" src="./components/scratch-pad.element.js"></script>

  <!-- The following is a hack to allow FFmpeg to use concurrent threads off the main JS thread and share data between themselves -->
  <!-- <script src="./lib/enable_threads.js"></script> -->

  <!-- The following provides the underlying music player and file analyser -->
  <script src="./lib/howler.min.js"></script>
  <script src="./lib/ffmpeg.min.js"></script>




</head>

<body>
  <header class="content">
    <button class="active" id="hamburger" aria-label="Open menu">&#9776;</button>
    <h1>Tanda Player Lite</h1>
    <label>View: <select id="modeSelector"></select></label>
  </header>
  <div id="settingsPanel" class="side-panel content">
    <button class="active" id="closeBtn" aria-label="Close Settings">&times;</button>
    <h2>Settings</h2>
    <ul>
      <li>Links to classification page</li>
      <li>Define playlist timings: between tracks, after tanda, before tanda</li>
      <li>Reset column widths to defaults</li>
      <li>Edit preferred text items</li>
    </ul>

    <p>To use another folder as the source of music files requires clearing the old database which is stored in the
      browser. If you wish to save the current library of tandas etc. that goes with the current folder, then use the
      "Export" feature first.</p>
    <button class="active" id="exportDatabase">Export Database</button>
    <button class="active" id="rescanButton">Re-scan for new files only</button>
    <button class="active" id="rescanAnalyzeButton">Re-Analyze</button>
    <button class="active" id="deleteDBButton">Reset Database</button>
    <button class="active" id="loadLibraryButton">Open existing Tanda Player Library</button>

    <section id="scannerProgress">
      <h3>File Scanner Progress</h3>
      <p id="scanProgress"></p>
      <p id="scanFilePath"></p>
      <p id="scanFileName"></p>
    </section>
  </div>

  <main class="all">
    <div id="searchColumn" class="column content">
      <div class="tabs pre-defined-search-choice">
        <div class="tab-headers">
          <div class="tab-header active" data-tab="search-controls">Search</div>
          <div class="tab-header" data-tab="favourites-results">Favourites<span id="favourites-count"></span></div>
        </div>

        <div class="tab-contents">
          <div class="tab-content active" id="search-controls">
            <label>Query: <input type="search" id="search" placeholder="Search titles, artists etc."></label>
            <section id="search-results">
              <div class="tabs tanda-tracks-choice  scrollable">
                <div class="tab-headers">
                  <div class="tab-header active" data-tab="tanda-results">Tandas<span id="tandas-count"></span></div>
                  <div class="tab-header" data-tab="track-results">Tracks<span id="tracks-count"></span></div>
                </div>
                <div class="tab-contents">
                  <div class="tab-content active" id="tanda-results">
                  </div>
                  <div class="tab-content" id="track-results">
                  </div>
                </div>
              </div>
            </section>

          </div>
          <div class="tab-content" id="favourites-results">
            <section id="favourites-results">
              <div class="tabs tanda-tracks-choice  scrollable">
                <div class="tab-headers">
                  <div class="tab-header active" data-tab="tanda-results">Tandas<span
                      id="favourites-tandas-count"></span></div>
                  <div class="tab-header" data-tab="track-results">Tracks<span id="favourites-tracks-count"></span>
                  </div>
                </div>
                <div class="tab-contents">
                  <div class="tab-content active" id="favourites-tanda-results">
                  </div>
                  <div class="tab-content" id="favourites-track-results">
                  </div>
                </div>
              </div>
            </section>
          </div>
        </div>
      </div>

      <ul>
        <li>Basic search</li>
        <li>Filter results by style and or other tags</li>
        <li>Via config, show standard lists: favourites, recently added, recently played</li>
        <li>Each item has click to move to clipboard</li>
      </ul>

    </div>
    <div class="handle" id="handle1"></div>
    <div id="scratchpadColumn" class="column content">
      <header class="playlistHeading">
        <h2>Scratch Pad</h2>
      </header>
      <ul>
        <li>New items added to top</li>
        <li>User can drag/drop and move items about</li>
        <li>Allow user to tag tandas or songs and allow grouping by them</li>
        <li>All tandas can be added to playlist: at current location, to end</li>
        <li>Content can be filtered by style or other tags</li>
      </ul>
      <scratch-pad-element id="scratchPad" playlistSelector="#playlist"></scratch-pad-element>
    </div>
    <div class="handle" id="handle2"></div>
    <div id="playlistColumn" class="column content">
      <section class="fixedColumnContent">
        <header class="playlistHeading">
          <h2>Playlist</h2>
          <section>
            <button id="stopButton"><img src="./icons/stopNow.png" alt="stop now"></button>
          </section>
          <section>
            <p>Show times:
              <label>Relative: <input type="radio" name="timingBase" value="relative">
                Real: <input type="radio" name="timingBase" value="realtime" checked="checked"></label>
            </p>
            <div class="playlist-settings-icon">⚙️</div>
          </section>
        </header>
        <div class="playlist-settings-panel">
          <header>
            <h1>Current Playlist Settings</h1>
            <button class="active playlist-settings-close-btn" aria-label="Close Playlist Settings">&times;</button>
          </header>
          <div class="playlist-settings-content">
            <form>
              <label class="field-container">Name: <input type="text" id="playlistName"></label>
              <label class="field-container">Cortina Set: <input type="text" id="cortinaSetName"></label>
              <label class="field-container">Tanda Style Sequence: <input type="text" id="tandaStyleSequence"
                  placeholder="E.g. 4T 4T 3W 4T 4T 3M"></label>
              <p>Time between tracks causes songs to overlap if a negative value is given and adds silence if positive.
                Note that songs are already trimmed of any leading and trailing silence.</p>
              <label class="field-container">Time between tracks: <input type="number" id="playlistTrackSpacing"
                  placeholder="Time in seconds between tracks"></label>
              <label class="field-container">Time before cortina: <input type="number" id="playlistPreCortina"
                  placeholder="Time in seconds before cortina (if used)"></label>
              <label class="field-container">Time after cortina: <input type="number" id="playlistPostCortina"
                  placeholder="Time in seconds after cortina (if used)"></label>
            </form>
          </div>
        </div>
        <ul>
          <li>Filter by artist, song</li>
        </ul>
      </section>
      <playlist-element id="playlist" scratchpadSelector="#scratchPad">
      </playlist-element>
    </div>
  </main>


  <!-- <label>Tempo: <input id="tempo" type="range" min="0.8" max="1.3" step="0.01" value="0"><button id="tempoReset">Reset</button></label>
  <label>Volume: <input id="volume" type="range" min="0" max="100" step="0.1" value="100"></label> -->
  <div id="output"></div>

  <div id="permissionModal" class="overlay">
    <div class="modal">
      <h2>Permission Request</h2>
      <p>Tanda Player needs your permission to read your music files folder for all files. Please click 'Allow' to
        continue.</p>
      <button class="active" id="askUserPermission">Allow</button>
    </div>
  </div>

  <!-- Manage core application start-up  -->
  <script type="module">
    import { DatabaseManager } from './lib/database.js';
    import { Player, to_time } from './lib/player.js';
    import { openMusicFolder, getAllFiles, verifyPermission, fetchLibraryFiles } from './lib/file_system.js';
    import { runFFmpegCommand, initializeFFmpeg, decodeFFmpegOutput } from './lib/ffmpeg-interface.js';

    const SYSTEM = {
      musicFolder: undefined
    }
    const CONFIG_ID = 1


    async function readMetadataFromFileHandle(fileHandle) {
      try {
        // Get the File object from the file handle
        const file = await fileHandle.getFile();
        const { convertedFile, outputLines } = await runFFmpegCommand(fileHandle, '-map', '0:a', '-af', 'volumedetect,silencedetect=n=-60dB:d=1', '-f', 'null', '-')
        const metadata = decodeFFmpegOutput(outputLines);
        return { size: convertedFile.byteLength, metadata };
      } catch (error) {
        console.error('Failed to read metadata:', error);
        return { size: 0, metadata: {} }
      }
    }

    document.addEventListener('DOMContentLoaded', async () => {
      await initializeFFmpeg();

      console.log('Set up handlers for column switching')
      const modeSelector = document.getElementById('modeSelector');
      const searchColumn = document.getElementById('searchColumn');
      const scratchpadColumn = document.getElementById('scratchpadColumn');
      const playlistColumn = document.getElementById('playlistColumn');
      const handle1 = document.getElementById('handle1');
      const handle2 = document.getElementById('handle2');

      // // Function to load widths from localStorage
      // function loadWidths(mode) {
      //   const widths = localStorage.getItem('widths_' + mode);
      //   if (widths) {
      //     const { col1Width, col3Width, col5Width } = JSON.parse(widths);
      //     col1.style.flexGrow = col1Width;
      //     col3.style.flexGrow = col3Width;
      //     col5.style.flexGrow = col5Width;
      //   }
      // }

      // // Function to save widths to localStorage
      // function saveWidths(mode) {
      //   const widths = {
      //     col1Width: col1.style.flexGrow,
      //     col3Width: col3.style.flexGrow,
      //     col5Width: col5.style.flexGrow
      //   };
      //   localStorage.setItem('widths_' + mode, JSON.stringify(widths));
      // }

      // Event listener for mode changes
      function changeScreenLayout(mode) {
        const main = document.querySelector('main');

        console.log('Mode', mode)
        switch (mode) {
          case 'All columns':
            main.classList.remove('playlistOnly')
            main.classList.remove('searchOnly')
            main.classList.add('all')
            break;
          case 'Search':
            main.classList.remove('playlistOnly')
            main.classList.add('searchOnly')
            main.classList.remove('all')
            break;
          case 'Playlist':
            main.classList.add('playlistOnly')
            main.classList.remove('searchOnly')
            main.classList.remove('all')
            break;
        }
        // loadWidths(mode);
      };


    // Add event listener for keydown event on the document
    document.addEventListener('keydown', function (event) {
      if (event.target.tagName !== 'INPUT' && event.target.tagName !== 'TEXTAREA') {
        // Check if a specific key or combination of keys is pressed
        if (event.key.toLowerCase() === 's') {
          // Perform your action here when CTRL+S is pressed
          console.log('S pressed');
          // Prevent the default browser action (e.g., saving the page)
          event.preventDefault();
          changeScreenLayout('Search')
        } else if (event.key.toLowerCase() === 'p') {
          // Perform your action here when the Escape key is pressed
          console.log('P key pressed');
          changeScreenLayout('Playlist')
        } else if (event.key.toLowerCase() === 'a') {
          // Perform your action here when the Escape key is pressed
          console.log('A key pressed');
          changeScreenLayout('All columns')
        }
        // Add more conditions for other key combinations as needed
      }
    });

    // Open and prepare the IndexedDB database

    const dbManager = await DatabaseManager();
    try {

      const config = await dbManager.getDataById('system', CONFIG_ID)

      if (!config) {
        // Set defaults
        await dbManager.addData('system', SYSTEM)
        console.log(`Set default config`)
      }

    } catch (error) {
      console.error('Database operation failed', error);
    }

    let config = await dbManager.getDataById('system', CONFIG_ID)

    let askUserPermissionButton = document.querySelector('#askUserPermission');
    askUserPermissionButton.addEventListener('click', async () => {
      runApplication();
    })

    let deleteDBButton = document.querySelector('#deleteDBButton')
    deleteDBButton.addEventListener('click', async () => {
      console.log('Deleting the database')
      await dbManager.resetDatabase();
      console.log('Restoring config')
      await dbManager.addData('system', SYSTEM)
      config = await dbManager.getDataById('system', CONFIG_ID)
      await setFolder();
    })
    let scanButton = document.querySelector('#rescanButton')
    scanButton.addEventListener('click', async () => {
      console.log('Re-scanning file system')
      await scanFileSystem(false)
    })
    let loadLibraryButton = document.querySelector('#loadLibraryButton')
    loadLibraryButton.addEventListener('click', async () => {
      const libraryFileHandles = await fetchLibraryFiles(config.musicFolder);
      if (libraryFileHandles) {
        console.log(libraryFileHandles)
        let file = await libraryFileHandles.library.getFile();
        const library = JSON.parse(await file.text())
        console.log(library)
        file = await libraryFileHandles.cortinas.getFile();
        const cortinas = JSON.parse(await file.text())
        console.log('cortinas', cortinas)
        file = await libraryFileHandles.tandas.getFile();
        const tandas = JSON.parse(await file.text())
        console.log('tandas', tandas)
        file = await libraryFileHandles.playlists.getFile();
        const playlists = JSON.parse(await file.text())
        console.log('playlists', playlists)

        let n = 0
        let keys = Object.keys(library)
        for (const trackName of keys) {
          scanFilePath.textContent = trackName;
          scanProgress.textContent = ++n + '/' + keys.length

          const existing = await dbManager.getDataByName('track', '/' + trackName);
          if (!existing) {
            console.log('Missing file', trackName)
          } else {
            const libTrack = library[trackName]
            const metadata = {
              tags: [
                { name: 'title', value: libTrack.track.title },
                { name: 'artist', value: libTrack.track.artist },
                { name: 'year', value: libTrack.track.date },
                { name: 'meanVolume', value: libTrack.analysis.meanGain },
                { name: 'maxVolume', value: libTrack.analysis.gain },
              ],
              start: libTrack.analysis.start,
              end: libTrack.analysis.silence,
              style: libTrack.classifiers?.style,
              duration: libTrack.analysis.duration,

            }
            existing.metadata = metadata
            await dbManager.updateData('track', existing.id, existing)
          }
        }

        // for ( let tanda of tandas ){
        //   tanda.tracks = tanda.tracks.map(track => '/' + track)
        //   const existing = dbManager.getDataById
        //   await dbManager.addData('tanda', tanda)
        // }
        const playlistContainer = document.querySelector('#playlist');


        function renderTrack(track) {
          return `<track-element 
            trackId="${track.id}"
            title="${track.metadata?.tags?.find(tag => tag.name == 'title')?.value || track.name}" 
            artist="${track.metadata?.tags?.find(tag => tag.name == 'artist')?.value || 'unknown'}" 
            style="${track.metadata?.style}"
            duration="${to_time(track.metadata?.duration * 1000)}" 
            year="${track.metadata?.tags?.find(tag => tag.name == 'date')?.value.substring(0, 10) || 'unknown'}">
          </track-element>`
        }
        let html = ''
        for (const tanda of tandas) {
          let tracks = []
          for (let i = 0; i < tanda.tracks.length; i++) {
            const track = await dbManager.getDataByName('track', '/' + tanda.tracks[i])
            console.log('Track?', track)
            if (track)
              tracks.push(track)
          }
          html += `<tanda-element>
<cortina-element trackId="12" title="Supertrooper" artist="Abba" style="T" duration="2:22" year="1940"></cortina-element>
${tracks.map(track => renderTrack(track)).join('')}
</tanda-element>`
        }
        playlistContainer.innerHTML = html

      }
    })

    // Find all song files and add to the database any not yet known

    const scanProgress = document.querySelector('#scanProgress')
    const scanFilePath = document.querySelector('#scanFilePath')
    const scanFileName = document.querySelector('#scanFileName')

    async function scanFileSystem(analyze) {
      let files = await getAllFiles(config.musicFolder);

      // Store all changes

      const fileHandles = {}
      let n = 0;
      for (const file of files) {
        scanFilePath.textContent = file.relativeFileName;
        scanFileName.textContent = file.name
        scanProgress.textContent = ++n + '/' + files.length
        const original = await dbManager.getDataByName('track', file.relativeFileName)
        if (!original) {
          const baseFile = await file.fileHandle.getFile();
          if (baseFile.size > 1000) {
            let size = baseFile.size;
            let metadata = { start: 0, end: -1, duration: undefined };
            if (analyze) {
              let { s, m } = await readMetadataFromFileHandle(file.fileHandle)
              size = s
              metadata = m
            }
            if (size > 1000) {
              const table = file.relativeFileName.split(/\/|\\/g)[1] == 'music' ? 'track' : 'cortina'
              await dbManager.addData(table, {
                name: file.fileHandle.name,
                fileHandle: file.fileHandle,
                relativeFileName: file.relativeFileName,
                metadata,
                classifiers: {
                  favourite: true,
                }
              })
            }
          }
        }
        // else {
        //   console.log('Already had details of ', file)
        // }
        //
      }

      console.log('Have now updated the database with all tracks')
    }

    async function setFolder() {

      await openMusicFolder(dbManager, config);

      await verifyPermission(config.musicFolder, 'readonly')

    }

    async function runApplication() {

      await setFolder();

      const modal = document.querySelector('#permissionModal');
      modal.classList = 'hidden'

      // Now query database for all tracks

      let systemLowestGain = { metadata: { meanVolume: 0, maxVolume: 0 } }

      const files = await dbManager.processEntriesInBatches('track', (record) => {
        let trackLevel = record.metadata.meanVolume - record.metadata.maxVolume
        let systemLevel = systemLowestGain.metadata.meanVolume - systemLowestGain.metadata.maxVolume
        if (trackLevel < systemLevel) systemLowestGain = record
        let extension = record.relativeFileName.split(".")
        extension = extension[extension.length - 1]
        return record.relativeFileName.split('/').length > 2 && extension == 'm4a'
      })

      console.log('Fetched all files', files.length, 'Lowest gain', systemLowestGain)

      const playlistContainer = document.querySelector('#playlist');

      playlistContainer.addEventListener('playFullCortina', async (event) => {
        const cortina = await dbManager.getDataById('cortina', event.target.querySelector('cortina-element').getAttribute('trackid'))
        player.extendEndTime(cortina.metadata.end)
      })
      playlistContainer.addEventListener('stopPlayFullCortina', async (event) => {
        player.extendEndTime(0)
      })

      playlistContainer.addEventListener('clickedTrack', async (event) => {
        try {
          console.log('Playlist detected clicked on tanda track', event.detail)
          if (!player.isPlaying) {
            const tracks = playlistContainer.querySelectorAll('track-element, cortina-element')
            let N = 0
            for (let i = 0; i < tracks.length; i++) {
              if (tracks[i] === event.detail) {
                N = i;
                console.log('Clicked on track N ', N)
              }
            }
            console.log('Nothing playing at the moment')
            await player.updatePosition(N - 1);
            player.next.silence = 0
            player.startNext();
            stopButton.classList.add('active')
          }
        } catch (error) {
          alert(error)
        }
      })

      // Create a dummy playlist



      // const items = new Array(100).fill(1)
      const items = files
      const tandas = []
      let tanda = []
      items.forEach((item) => {
        if (tanda.length == 4) {
          tandas.push(tanda);
          tanda = []
        }
        tanda.push(item)
      })

      function renderTrack(track) {
        return `<track-element 
            trackId="${track.id}"
            title="${track.metadata?.tags?.find(tag => tag.name == 'title')?.value || track.name}" 
            artist="${track.metadata?.tags?.find(tag => tag.name == 'artist')?.value || 'unknown'}" 
            style="${track.metadata?.style}"
            duration="${to_time(track.metadata?.duration * 1000)}" 
            year="${track.metadata?.tags?.find(tag => tag.name == 'date')?.value.substring(0, 10) || 'unknown'}">
          </track-element>`
      }

      console.log(tandas)
      playlistContainer.innerHTML = `${tandas.map((tanda) => {

        return `<tanda-element>
    <cortina-element trackId="12" title="Supertrooper" artist="Abba" style="T" duration="2:22" year="1940"></cortina-element>
    ${renderTrack(tanda[0])}
    ${renderTrack(tanda[1])}
    ${renderTrack(tanda[2])}
    ${renderTrack(tanda[3])}
</tanda-element>`
      }).join('')}`

      const h = document.querySelector('h1')
      let now;
      async function reportProgress(data) {
        if (!now) now = new Date().getTime();
        h.textContent = data.display// + `    Elapsed from start: ${to_time(new Date().getTime() - now)}`
      }

      // let tempoControl = document.querySelector('#tempo')



      // Need to work out what is currently playing and what should come next.
      // The what came before determines pre-cortina silences
      // If new element is the same type as the last one, add normal inter-song silences
      // if old was track and new is cortina then add pre-cortina
      // if new is track and old is cortina then add post-cortina
      async function nextTrack(N) {

        const timings = {
          playlistPreCortina: 3,
          playlistPostCortina: 3,
          playlistInterSong: 2,
          playlistCortinaDuration: 14
        }

        // tempoControl.value = 1;

        // Find Nth track in playlist
        const tracks = [...playlistContainer.querySelectorAll('track-element, cortina-element')];
        if (N < tracks.length) {
          let track = tracks[N]
          let previous = tracks[N - 1]
          if (previous.tagName == 'CORTINA-ELEMENT' && track.tagName == 'TRACK-ELEMENT') {
            return {
              track: await dbManager.getDataById('track', parseInt(track.getAttribute('trackid'))),
              silence: timings.playlistPostCortina
            }
          }

          // If next is a cortina, modify the playing time
          if (previous.tagName == 'TRACK-ELEMENT' && track.tagName == 'CORTINA-ELEMENT') {
            let trackData = await dbManager.getDataById('cortina', parseInt(track.getAttribute('trackid')));
            trackData.metadata.end = timings.playlistCortinaDuration
            return {
              track: trackData,
              silence: timings.playlistPreCortina
            }
          }
          return {
            track: await dbManager.getDataById(track.tagName == 'TRACK-ELEMENT' ? 'track' : 'cortina', parseInt(track.getAttribute('trackid'))),
            silence: timings.playlistInterSong
          }
        } else {
          return { track: null, silence: null }
        }
      }

      function playing(N) {
        playlistContainer.playing(N)
      }

      // Assume an output device has been selected

      let player = new Player({
        systemLowestGain,
        fadeRate: 2000, // time over which to fade out 
        progress: reportProgress,
        nextUp: nextTrack,
        playing
      })

      // tempoControl.addEventListener('input', ()=>{
      //   player.setTempo(tempoControl.value)
      // })

      // let tempoReset = document.querySelector('#tempoReset')
      // tempoReset.addEventListener('click', ()=>{
      //   tempoControl.value = 1;
      //   player.setTempo(1)
      // })

      // let volumeControl = document.querySelector('#volume')
      // volumeControl.addEventListener('input', ()=>{
      //   player.volume(volumeControl.value)
      // })


      // await player.updatePosition(1);
      // player.startNext();

      const stopButton = document.querySelector('#stopButton')
      stopButton.classList.add('active')
      stopButton.addEventListener('click', () => {
        stopButton.classList.remove('active');
        player.stop();
      })


      window.addEventListener('beforeunload', function (event) {
        // Set the returnValue property of the event to a custom message.
        // Modern browsers display a standard message that cannot be customized due to security reasons,
        // but setting returnValue is still necessary to trigger the dialog.
        event.returnValue = 'Are you sure you want to leave?';
      });

    }

    });

    // document.getElementById('folderInput').addEventListener('change', async (event) => {
    //   files = event.target.files;

    //   for (const file of files) {
    //     console.log(file.name, file.lastModified, file.lastModifiedDate, file.size, file.webkitRelativePath)
    //     await readID3Tags(file);
    //   }
    // });

    // async function readID3Tags(file) {
    //   const tags = await id3.fromFile(file);

    //   // Output tags to the div
    //   const outputDiv = document.getElementById('output');
    //   outputDiv.innerHTML += `<pre>${file.name}: ${JSON.stringify(tags, null, 2)}</pre><button data-file-name="${file.name}" data-file-type="${file.type}">Play</button>`;
    //   let button = outputDiv.querySelector('button');
    //   button.addEventListener('click', () => {
    //     play(button)
    //   })
    //   console.log(button)
    // }

  </script>

  <!-- handle hamberger menu and settings tabs -->
  <script>
    document.addEventListener('DOMContentLoaded', async () => {

      document.getElementById('hamburger').addEventListener('click', function () {
        document.getElementById('settingsPanel').style.transform = 'translateX(800px)';
      });

      document.getElementById('closeBtn').addEventListener('click', function () {
        document.getElementById('settingsPanel').style.transform = 'translateX(-800px)';
      });

      document.querySelector('.playlist-settings-icon').addEventListener('click', function () {
        const panel = document.querySelector('.playlist-settings-panel');
        panel.classList.toggle('active');
      })

      document.querySelector('.playlist-settings-close-btn').addEventListener('click', function () {
        const panel = document.querySelector('.playlist-settings-panel');
        panel.classList.toggle('active');
      })

    });

  </script>

  <!-- Handle user's choice of visible columns -->
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      console.log('Set up handlers for column switching')
      const modeSelector = document.getElementById('modeSelector');
      const searchColumn = document.getElementById('searchColumn');
      const scratchpadColumn = document.getElementById('scratchpadColumn');
      const playlistColumn = document.getElementById('playlistColumn');
      const handle1 = document.getElementById('handle1');
      const handle2 = document.getElementById('handle2');

      // // Function to load widths from localStorage
      // function loadWidths(mode) {
      //   const widths = localStorage.getItem('widths_' + mode);
      //   if (widths) {
      //     const { col1Width, col3Width, col5Width } = JSON.parse(widths);
      //     col1.style.flexGrow = col1Width;
      //     col3.style.flexGrow = col3Width;
      //     col5.style.flexGrow = col5Width;
      //   }
      // }

      // // Function to save widths to localStorage
      // function saveWidths(mode) {
      //   const widths = {
      //     col1Width: col1.style.flexGrow,
      //     col3Width: col3.style.flexGrow,
      //     col5Width: col5.style.flexGrow
      //   };
      //   localStorage.setItem('widths_' + mode, JSON.stringify(widths));
      // }

      // Event listener for mode changes
      modeSelector.addEventListener('change', function () {
        const main = document.querySelector('main');
        const mode = modeSelector.value;

        console.log('Mode', mode)
        switch (mode) {
          case 'All columns':
            main.classList.remove('playlistOnly')
            main.classList.remove('searchOnly')
            main.classList.add('all')
            break;
          case 'Search':
            main.classList.remove('playlistOnly')
            main.classList.add('searchOnly')
            main.classList.remove('all')
            break;
          case 'Playlist':
            main.classList.add('playlistOnly')
            main.classList.remove('searchOnly')
            main.classList.remove('all')
            break;
        }
        // loadWidths(mode);
      });

      // // Initialize with default mode
      // modeSelector.value = 'all';
      // loadWidths('all');
    });
  </script>

  <!-- Handle column width adjustments -->
  <script>
    document.addEventListener('DOMContentLoaded', function () {

      console.log('Setting up column width handlers')
      const container = document.querySelector('main');
      let startX, startWidthLeft, startWidthRight, handleBeingDragged;

      const dragStart = (e) => {
        handleBeingDragged = e.target;
        startX = e.clientX;
        const prevCol = handleBeingDragged.previousElementSibling;
        const nextCol = handleBeingDragged.nextElementSibling;
        startWidthLeft = prevCol.offsetWidth;
        startWidthRight = nextCol.offsetWidth;
        document.addEventListener('mousemove', dragMove);
        document.addEventListener('mouseup', dragEnd);
      };

      const dragMove = (e) => {
        if (!handleBeingDragged) return;
        const dx = e.clientX - startX;
        const newLeftWidth = startWidthLeft + dx;
        const newRightWidth = startWidthRight - dx;
        const gridTemplateColumns = Array.from(container.children).map(child => {
          if (child === handleBeingDragged.previousElementSibling) {
            return `${newLeftWidth}px`;
          } else if (child === handleBeingDragged) {
            return '10px'; // handle width
          } else if (child === handleBeingDragged.nextElementSibling) {
            return `${newRightWidth}px`;
          } else {
            return `${child.style.flexGrow || '1fr'}`;
          }
        }).join(' ');
        container.style.gridTemplateColumns = gridTemplateColumns;
      };

      const dragEnd = () => {
        document.removeEventListener('mousemove', dragMove);
        document.removeEventListener('mouseup', dragEnd);
        handleBeingDragged = null;
      };

      const handles = document.querySelectorAll('.handle');
      handles.forEach(handle => handle.addEventListener('mousedown', dragStart));
    });

  </script>

  <!-- Handle language preferences -->
  <script>

    const configurableItems = [
      {
        type: 'select', selector: '#modeSelector',
        textValues: ['All columns', 'Search', 'Playlist'],
        preferredValues: ['All columns', 'Search', 'Playlist']
      },
      {
        type: 'select', selector: '.style-select',
        textValues: ['All styles', 'Tango', 'Waltz', 'Milonga'],
        preferredValues: ['All styles', 'Tango', 'Vals', 'Milonga']
      }
    ];

    const configuredItems = localStorage.getItem('Text Preferences') || configurableItems;

    /* Populate the page with user's preferred text */
    configuredItems.forEach((item) => {
      switch (item.type) {
        case 'select':
          const elements = document.querySelectorAll(item.selector)
          for (const e of elements) {
            e.innerHTML = item.textValues.map((value, idx) => {
              return `<option value="${value}">${item.preferredValues[idx]}</option>`
            }).join('')
          }
          break;
      }
    })

    console.log('Set up language support')

  </script>

  <!-- Searches -->
  <script type="module">
    import { DatabaseManager } from './lib/database.js';

    let headers = document.querySelectorAll('.tanda-tracks-choice > .tab-headers > .tab-header');
    let contents = document.querySelectorAll('.tanda-tracks-choice > .tab-contents > .tab-content');

    headers.forEach(header => {
      const localHeaders = headers;
      const localContents = contents;
      header.addEventListener('click', function () {
        const targetId = this.getAttribute('data-tab');

        // Remove active class from all headers and contents
        localHeaders.forEach(h => h.classList.remove('active'));
        localContents.forEach(c => c.classList.remove('active'));

        // Add active class to clicked header and corresponding content
        this.classList.add('active');
        document.getElementById(targetId).classList.add('active');
      });
    });

    headers = document.querySelectorAll('.pre-defined-search-choice > .tab-headers > .tab-header');
    contents = document.querySelectorAll('.pre-defined-search-choice > .tab-contents > .tab-content');

    headers.forEach(header => {
      const localHeaders = headers;
      const localContents = contents;
      header.addEventListener('click', function () {
        const targetId = this.getAttribute('data-tab');

        // Remove active class from all headers and contents
        localHeaders.forEach(h => h.classList.remove('active'));
        localContents.forEach(c => c.classList.remove('active'));

        // Add active class to clicked header and corresponding content
        this.classList.add('active');
        document.getElementById(targetId).classList.add('active');
      });
    });

    document.addEventListener('DOMContentLoaded', async function () {

      const dbManager = await DatabaseManager();


      const searchText = document.querySelector('#search');
      const tandaResults = document.querySelector('#tanda-results');
      const trackResults = document.querySelector('#track-results');
      const tandasCount = document.querySelector('#tandas-count');
      const tracksCount = document.querySelector('#tracks-count');
      console.log('About to set up search')
      searchText.addEventListener('change', async () => {
        console.log(searchText.value)

        // Clear results
        tandaResults.innerHTML = '';
        trackResults.innerHTML = '';

        // Get track results
        dbManager.processEntriesInBatches('track', (record) => {
          return true;
        }).then((tracks) => {
          tracksCount.textContent = tracks.length;
          trackResults.innerHTML = tracks.map((result) => {
            return `<file-display data-file='{
    "summary": {"name": "${result.relativeFileName}", "size": "14KB"},
    "details": {"type": "Text File", "created": "2023-01-01"}
}'></file-display>`
          }).join('')
        })

        // Get tanda results
        dbManager.processEntriesInBatches('tanda', (record) => {
          return true;
        }).then((tandas) => {
          tandasCount.textContent = tandas.length
          trackResults.innerHTML = tandas.map((result) => {
            return `<file-display data-file='{
    "summary": {"name": "${result.relativeFileName}", "size": "14KB"},
    "details": {"type": "Text File", "created": "2023-01-01"}
}'></file-display>`
          }).join('')
        })

      })

      const favouriteTracks = document.querySelector('#favourites-track-results');
      const favouriteTandas = document.querySelector('#favourites-tandas-results');
      const favouriteTandasCount = document.querySelector('#favourites-tandas-count');
      const favouriteTracksCount = document.querySelector('#favourites-tracks-count');



    });
  </script>

  <!-- Handle settings -->
  <script type="module">
    import { DatabaseManager } from './lib/database.js';
    import { saveFileWithWritePermission } from './lib/file_system.js'

    document.addEventListener('DOMContentLoaded', async function () {
      const dbManager = await DatabaseManager();
      let libraryFileHandle = null;

      const exportButton = document.querySelector('#exportDatabase');
      exportButton.addEventListener('click', async () => {
        console.log('Exporting the database');
        const allData = await dbManager.exportAllData();
        console.log(allData)
        // const blob = new Blob([allData], { type: 'application/json' });
        // const url = URL.createObjectURL(blob);

        // // Create a link and trigger the download
        // const a = document.createElement('a');
        // a.href = url;
        // a.download = `tanda-player-library-backup.json`;
        // document.body.appendChild(a);
        // a.click();
        // document.body.removeChild(a);

        // // Revoke the blob URL after a delay
        // setTimeout(() => URL.revokeObjectURL(url), 100);

        libraryFileHandle = saveFileWithWritePermission(libraryFileHandle, allData);

      })
    });
  </script>
</body>

</html>